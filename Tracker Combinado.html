<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Tracker Completo: Manos, Cabeza y Ojos</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    html, body {
      margin: 0; padding: 0; overflow: hidden;
      width: 100%; height: 100%; background: #000;
    }
    /* Ocultamos el vídeo, dibujamos todo en el canvas */
    video#input_video {
      position: absolute; top: 0; left: 0;
      width: 100%; height: 100%;
      object-fit: cover; opacity: 0;
    }
    canvas#output_canvas {
      position: absolute; top: 0; left: 0;
      width: 100%; height: 100%;
    }
  </style>
  <!-- MediaPipe Hands, FaceMesh y Drawing Utils -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
</head>
<body>
  <video id="input_video" playsinline muted autoplay></video>
  <canvas id="output_canvas"></canvas>

  <script>
    const video = document.getElementById('input_video');
    const canvas = document.getElementById('output_canvas');
    // Para acelerar getImageData en algunos navegadores:
    const ctx = canvas.getContext('2d', { willReadFrequently: true });

    // Colores por dedo (¡tal cual tu código original!)
    const fingerColors = {
      thumb:  '#FF0000',
      index:  '#00FF00',
      middle: '#0000FF',
      ring:   '#FFFF00',
      pinky:  '#FF00FF'
    };

    let handLandmarks = [], faceResults = null;

    // 1) Inicializar cámara
    navigator.mediaDevices.getUserMedia({ video: true })
      .then(stream => { video.srcObject = stream; })
      .catch(err => alert('No se pudo acceder a la cámara: ' + err));

    // 2) Configurar MediaPipe Hands
    const hands = new Hands({
      locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`
    });
    hands.setOptions({
      maxNumHands: 2,
      modelComplexity: 1,
      minDetectionConfidence: 0.7,
      minTrackingConfidence: 0.7
    });
    hands.onResults(results => {
      handLandmarks = results.multiHandLandmarks || [];
    });

    // 3) Configurar MediaPipe FaceMesh
    const faceMesh = new FaceMesh({
      locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${f}`
    });
    faceMesh.setOptions({
      maxNumFaces: 1,
      refineLandmarks: true,
      minDetectionConfidence: 0.7,
      minTrackingConfidence: 0.7
    });
    faceMesh.onResults(results => {
      faceResults = results;
    });

    // 4) Bucle de dibujo
    async function onFrame() {
      if (video.readyState >= HTMLMediaElement.HAVE_CURRENT_DATA) {
        // 4.1 Procesar ambas redes
        await hands.send({ image: video });
        await faceMesh.send({ image: video });

        // 4.2 Preparamos canvas
        const vw = video.videoWidth, vh = video.videoHeight;
        const cw = canvas.width  = window.innerWidth;
        const ch = canvas.height = window.innerHeight;
        const scale = Math.min(cw/vw, ch/vh);
        const dw = vw * scale, dh = vh * scale;
        const dx = (cw - dw) / 2, dy = (ch - dh) / 2;

        ctx.save();
        // espejo horizontal
        ctx.translate(cw, 0);
        ctx.scale(-1, 1);
        // pinta el vídeo
        ctx.drawImage(video, 0, 0, vw, vh, dx, dy, dw, dh);

        // 4.3 --- DIBUJAR MANOS (tu código original) ---
        handLandmarks.forEach(landmarks => {
          // Conectores verdes
          ctx.strokeStyle = '#00FF00';
          ctx.lineWidth = 2;
          HAND_CONNECTIONS.forEach(([i, j]) => {
            const p1 = landmarks[i], p2 = landmarks[j];
            ctx.beginPath();
            ctx.moveTo(dx + p1.x * dw, dy + p1.y * dh);
            ctx.lineTo(dx + p2.x * dw, dy + p2.y * dh);
            ctx.stroke();
          });
          // Puntos coloreados por dedo
          landmarks.forEach((lm, i) => {
            const x = dx + lm.x * dw, y = dy + lm.y * dh;
            let color = '#FFFFFF';
            if (i >= 1  && i <= 4)   color = fingerColors.thumb;
            if (i >= 5  && i <= 8)   color = fingerColors.index;
            if (i >= 9  && i <= 12)  color = fingerColors.middle;
            if (i >= 13 && i <= 16)  color = fingerColors.ring;
            if (i >= 17 && i <= 20)  color = fingerColors.pinky;
            ctx.beginPath();
            ctx.arc(x, y, 6, 0, 2 * Math.PI);
            ctx.fillStyle = color;
            ctx.fill();
          });
        });

        // 4.4 --- DIBUJAR CABEZA Y OJOS (FaceMesh) ---
        if (faceResults && faceResults.multiFaceLandmarks.length) {
          const lm = faceResults.multiFaceLandmarks[0];
          // Calcular bbox de la cara
          let minX=1, minY=1, maxX=0, maxY=0;
          lm.forEach(p => {
            minX = Math.min(minX, p.x);
            minY = Math.min(minY, p.y);
            maxX = Math.max(maxX, p.x);
            maxY = Math.max(maxY, p.y);
          });
          ctx.strokeStyle = '#00FF00';
          ctx.lineWidth = 2;
          ctx.strokeRect(
            dx + minX * dw,
            dy + minY * dh,
            (maxX - minX) * dw,
            (maxY - minY) * dh
          );

          // Bbox ojos (índices de FaceMesh)
          const leftEyeIdx  = [33, 133, 159, 145];
          const rightEyeIdx = [362, 263, 386, 374];
          [leftEyeIdx, rightEyeIdx].forEach(indices => {
            let exMin=1, eyMin=1, exMax=0, eyMax=0;
            indices.forEach(i => {
              const p = lm[i];
              exMin = Math.min(exMin, p.x);
              eyMin = Math.min(eyMin, p.y);
              exMax = Math.max(exMax, p.x);
              eyMax = Math.max(eyMax, p.y);
            });
            ctx.strokeStyle = '#FF0000';
            ctx.lineWidth = 2;
            ctx.strokeRect(
              dx + exMin * dw,
              dy + eyMin * dh,
              (exMax - exMin) * dw,
              (eyMax - eyMin) * dh
            );
          });
        }

        ctx.restore();
      }
      requestAnimationFrame(onFrame);
    }

    // 5) Arrancar loop cuando el vídeo esté listo
    video.addEventListener('playing', onFrame);
  </script>
</body>
</html>
