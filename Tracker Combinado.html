<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <title>Tracker Combinado</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="styles.css">
  <script>
    window.Module = window.Module || {};
    if (!('arguments_' in Module)) Module.arguments_ = [];
    if (!('arguments' in Module)) Module.arguments = Module.arguments_;
    window.USE_CDN = false;
  </script>
  <script src="libs/hands.js" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js';window.USE_CDN=true;"></script>
  <script src="libs/face_mesh.js" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js';window.USE_CDN=true;"></script>
  <script src="libs/drawing_utils.js" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js';window.USE_CDN=true;"></script>
  <script src="libs/pose.js" onerror="this.onerror=null;this.src='https://cdn.jsdelivr.net/npm/@mediapipe/pose/pose.js';window.USE_CDN=true;"></script>
</head>
<body>
  <video id="video" autoplay muted playsinline></video>
  <canvas id="trackerCanvas"></canvas>
  <script>
    const style = getComputedStyle(document.documentElement);
    const accent = style.getPropertyValue('--accent').trim() || '#2EB8A3';

    const video = document.getElementById('video');
    const canvas = document.getElementById('trackerCanvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: true });

    navigator.mediaDevices.getUserMedia({ video: true })
      .then(s => video.srcObject = s)
      .catch(err => alert('No se pudo acceder a la cÃ¡mara: ' + err));

    const hands = new Hands(window.USE_CDN ? {} : { locateFile: f => `libs/${f}` });
    hands.setOptions({ maxNumHands: 2, modelComplexity: 1, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
    let handLandmarks = [];
    hands.onResults(r => { handLandmarks = r.multiHandLandmarks || []; });

    const faceMesh = new FaceMesh(window.USE_CDN ? {} : { locateFile: f => `libs/${f}` });
    faceMesh.setOptions({ maxNumFaces: 1, refineLandmarks: true, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
    let faceLandmarks = null;
    faceMesh.onResults(r => { faceLandmarks = r.multiFaceLandmarks && r.multiFaceLandmarks[0] || null; });

    const pose = new Pose(window.USE_CDN ? {} : { locateFile: f => `libs/${f}` });
    pose.setOptions({ modelComplexity: 1, enableSegmentation: false, minDetectionConfidence: 0.7, minTrackingConfidence: 0.7 });
    let poseLandmarks = null;
    pose.onResults(r => { poseLandmarks = r.poseLandmarks || null; });

    async function onFrame() {
      if (video.readyState >= HTMLMediaElement.HAVE_CURRENT_DATA) {
        await Promise.all([
          hands.send({ image: video }),
          faceMesh.send({ image: video }),
          pose.send({ image: video })
        ]);
        const vw = video.videoWidth, vh = video.videoHeight;
        if (canvas.width !== vw || canvas.height !== vh) { canvas.width = vw; canvas.height = vh; }
        ctx.clearRect(0, 0, vw, vh);

        handLandmarks.forEach(lm => {
          ctx.strokeStyle = accent;
          ctx.lineWidth = 2;
          HAND_CONNECTIONS.forEach(([i,j]) => {
            const p1 = lm[i], p2 = lm[j];
            ctx.beginPath();
            ctx.moveTo(p1.x * vw, p1.y * vh);
            ctx.lineTo(p2.x * vw, p2.y * vh);
            ctx.stroke();
          });
          ctx.fillStyle = accent;
          lm.forEach(p => { ctx.beginPath(); ctx.arc(p.x * vw, p.y * vh, 4, 0, Math.PI*2); ctx.fill(); });
        });

        if (faceLandmarks) {
          ctx.strokeStyle = accent;
          ctx.lineWidth = 2;
          drawConnectors(ctx, faceLandmarks, FACEMESH_LEFT_EYE, { color: accent, lineWidth: 2 });
          drawConnectors(ctx, faceLandmarks, FACEMESH_RIGHT_EYE, { color: accent, lineWidth: 2 });
          drawConnectors(ctx, faceLandmarks, FACEMESH_LIPS, { color: accent, lineWidth: 2 });
        }

        if (poseLandmarks) {
          drawConnectors(ctx, poseLandmarks, POSE_CONNECTIONS, { color: accent, lineWidth: 2 });
          ctx.fillStyle = accent;
          poseLandmarks.forEach(p => { ctx.beginPath(); ctx.arc(p.x * vw, p.y * vh, 3, 0, Math.PI*2); ctx.fill(); });
        }
      }
      requestAnimationFrame(onFrame);
    }
    video.addEventListener('playing', onFrame);
  </script>
</body>
</html>
